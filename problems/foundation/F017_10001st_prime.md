---
id: F017
euler_id: 7
slug: 10001st-prime
title: 10001st Prime
difficulty: foundation
topics: ["math", "primes", "prime-generation"]
patterns: []
estimated_time_minutes: 12
prerequisites: ["programming-basics"]
---

# 10001st Prime

## Problem

Find the nth prime number. The sequence of prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, ...

For example, the 1st prime is 2, the 2nd prime is 3, the 6th prime is 13, and the 10,001st prime is what you need to find.

A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. In other words, a prime number cannot be formed by multiplying two smaller natural numbers.

## Why This Matters

Prime numbers are the building blocks of all integers—every positive integer can be uniquely factored into primes (the Fundamental Theorem of Arithmetic). This makes primes essential to number theory, cryptography, and algorithm design.

This problem teaches you prime testing through trial division: to check if a number n is prime, test if any number from 2 to √n divides it. The square root bound is a key optimization—if n has a divisor greater than √n, it must also have a corresponding divisor less than √n.

Prime generation appears everywhere in computer science:
- **Cryptography**: RSA encryption relies on the difficulty of factoring the product of two large primes
- **Hash tables**: Prime-sized tables reduce collision rates
- **Random number generation**: Prime moduli improve randomness properties
- **Distributed systems**: Consistent hashing uses primes for better load distribution

For large-scale prime generation, you'll eventually learn the Sieve of Eratosthenes (covered in F018), but trial division is simpler and sufficient for finding individual primes or generating small sequences.

## Examples

**Example 1:**

- Input: `n = 6`
- Output: `13`
- Explanation: The first six primes are 2, 3, 5, 7, 11, 13. The 6th prime is 13.

**Example 2:**

- Input: `n = 10001`
- Output: `104743`
- Explanation: The 10,001st prime number is 104,743.

## Constraints

- 1 <= n <= 10^6
- The answer will fit in a 32-bit signed integer for n <= 10^6

## Think About

1. How do you test if a single number is prime?
2. Why can you stop testing divisors at √n?
3. What optimizations can you apply after checking for divisibility by 2?
4. How might you estimate roughly where the nth prime is located?

---

## Approach Hints

<details>
<summary>Hint 1: Testing Primality</summary>

To check if a number n is prime:
1. If n < 2, it's not prime
2. If n == 2, it's prime (the only even prime)
3. If n is even (n % 2 == 0), it's not prime
4. For odd n, check if any odd number from 3 to √n divides n
5. If no divisor found, n is prime

**Why √n?** If n = a × b and a > √n, then b < √n. So if n has a factor, at least one of them must be ≤ √n.

**Example:** Is 29 prime?
- √29 ≈ 5.38
- Test: 29 % 3 = 2 (not divisible), 29 % 5 = 4 (not divisible)
- No divisors found up to √29, so 29 is prime

</details>

<details>
<summary>Hint 2: Generating Primes Sequentially</summary>

To find the nth prime:
1. Start with candidate = 2, prime_count = 0
2. For each candidate number:
   - Test if it's prime using trial division
   - If prime, increment prime_count
   - If prime_count == n, return candidate
   - Move to next candidate (2 → 3, then increment by 2 to skip even numbers)

**Optimization:** After checking 2, you only need to check odd numbers. This cuts your search space in half.

</details>

<details>
<summary>Hint 3: Implementation Pattern</summary>

```
function is_prime(n):
    if n < 2: return false
    if n == 2: return true
    if n % 2 == 0: return false

    for divisor from 3 to sqrt(n) step 2:
        if n % divisor == 0:
            return false

    return true

function nth_prime(n):
    if n == 1: return 2

    count = 1  # We've counted prime #1 (which is 2)
    candidate = 3  # Start checking from 3

    while count < n:
        if is_prime(candidate):
            count += 1
        candidate += 2  # Skip even numbers

    return candidate - 2  # Backtrack to the last prime found
```

**Further optimization:** You could skip multiples of 3 as well (check 2, 3, then 6k±1 pattern), but for n ≤ 10^6, simple trial division is sufficient.

</details>

---

## Complexity Analysis

| Approach | Time | Space | Trade-off |
|----------|------|-------|-----------|
| Trial Division | O(n × √p_n) | O(1) | Simple; tests each candidate individually |
| Sieve of Eratosthenes | O(p_n log log p_n) | O(p_n) | Faster for multiple primes; requires memory |

**Where p_n is the nth prime (approximately n × ln(n) by the Prime Number Theorem).**

**For this problem:** Trial division is simpler to implement and uses O(1) space. For n = 10,001, the 10,001st prime is about 104,743, and testing primality up to that point is fast enough.

**When to use Sieve:** If you need all primes up to a limit (see F018: Summation of Primes), or if you're answering many queries about primes in a range, the sieve is more efficient.

---

## Key Concept

**Trial Division and the √n Optimization**

Trial division is the simplest primality test: try dividing n by all possible factors. The key insight is that you only need to test up to √n.

**Why?** Suppose n = a × b where a ≤ b. Then a ≤ √n ≤ b. If n has any factors, at least one must be ≤ √n. So if you test all numbers up to √n and find no factors, n must be prime.

**Example:** To test if 91 is prime:
- √91 ≈ 9.54
- Test: 91 % 2 = 1 ✗, 91 % 3 = 1 ✗, 91 % 5 = 1 ✗, 91 % 7 = 0 ✓
- Found divisor 7, so 91 = 7 × 13 is composite

**Skip even numbers:** After checking if n is divisible by 2, you only need to check odd divisors (3, 5, 7, 9, ...). This halves the number of checks.

**Prime Number Theorem:** The nth prime is approximately n × ln(n). This gives you a rough estimate of where to search. For n = 10,001, the prime is around 10,001 × ln(10,001) ≈ 92,000 (actual: 104,743).

---

## Common Mistakes

1. **Forgetting that 2 is the only even prime**: Many beginners exclude 2 or handle it incorrectly. Always treat 2 as a special case.

2. **Testing up to n instead of √n**: Testing all numbers from 2 to n-1 is correct but wasteful. Always optimize to √n.

3. **Using floating-point sqrt**: In some languages, int(sqrt(n)) can have precision issues. Safer: `while divisor * divisor <= n` instead of `while divisor <= sqrt(n)`.

4. **Off-by-one errors in counting**: Make sure you're counting correctly. The 1st prime is 2, not 3. The loop should increment the counter when a prime is found, not before.

5. **Not skipping even numbers after 2**: Your candidate loop should go 2, 3, 5, 7, 9, 11, ... (increment by 2 after 3), not 2, 3, 4, 5, 6, ...

---

## Variations

| Variation | Change | Approach Adjustment |
|-----------|--------|---------------------|
| Check if single number is prime | Given n, return true/false | Just the is_prime function |
| All primes up to limit | Find all primes ≤ N | Use Sieve of Eratosthenes (F018) |
| Prime in a range | Find primes between L and R | Sieve up to R, filter to [L, R] |
| Next prime after N | Find smallest prime > N | Start from N+1, test each candidate |
| Count primes ≤ N | How many primes up to N? | Sieve and count |

---

## Practice Checklist

**Correctness:**

- [ ] Handles n = 1 (returns 2)
- [ ] Handles small cases (n = 6 returns 13)
- [ ] Correctly identifies 2 as prime
- [ ] Produces correct result for n = 10,001

**Understanding:**

- [ ] Can explain why we only test up to √n
- [ ] Understands why we skip even numbers after 2
- [ ] Can estimate the nth prime using Prime Number Theorem

**Mastery:**

- [ ] Solved without hints
- [ ] Implemented is_prime function from scratch
- [ ] Can discuss trade-offs vs. Sieve approach

**Spaced Repetition Tracker:**

- [ ] Day 1: Initial solve
- [ ] Day 3: Solve without hints
- [ ] Day 7: Implement both trial division and sieve versions
- [ ] Day 14: Explain why √n optimization works

---

**Euler Reference:** [Problem 7](https://projecteuler.net/problem=7)

**Next Step:** After mastering this, try [F018: Summation of Primes](F018_summation_of_primes.md) to learn the Sieve of Eratosthenes
