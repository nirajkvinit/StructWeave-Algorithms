---
id: F015
euler_id: 12
slug: highly-divisible-triangular-number
title: Highly Divisible Triangular Number
difficulty: foundation
topics: ["math", "triangular-numbers", "divisors"]
patterns: []
estimated_time_minutes: 15
prerequisites: ["programming-basics"]
---

# Highly Divisible Triangular Number

## Problem

Triangular numbers are generated by summing consecutive natural numbers. The sequence begins: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

The nth triangular number T(n) is the sum 1 + 2 + 3 + ... + n, which equals n × (n + 1) / 2.

**Examples of triangular numbers and their divisors:**
- T(7) = 28 has divisors: 1, 2, 4, 7, 14, 28 → 6 divisors
- T(10) = 55 has divisors: 1, 5, 11, 55 → 4 divisors

Find the first triangular number that has more than k divisors. For example, if k = 5, the answer is 28, because T(7) = 28 is the first triangular number with more than 5 divisors (it has 6).

## Why This Matters

This problem combines three important mathematical concepts:

**1. Triangular Numbers**: These appear throughout mathematics and computer science:
- **Combinatorics**: T(n) counts the number of ways to choose 2 items from n+1 items (binomial coefficient C(n+1, 2))
- **Algorithm analysis**: Nested loops often have Θ(n²) complexity because they perform T(n) iterations
- **Graph theory**: A complete graph with n vertices has T(n-1) edges

**2. Divisor Counting**: The number of divisors d(n) has applications in:
- **Cryptography**: Numbers with few divisors (primes) are preferred for key generation
- **Algorithm optimization**: Understanding divisor distribution helps in factorization algorithms
- **Number theory**: Divisor functions connect to deep results like the Riemann Hypothesis

**3. Multiplicative Functions**: The key insight is that d(n) is multiplicative: if gcd(a, b) = 1, then d(a × b) = d(a) × d(b). This property allows efficient computation using prime factorization.

This problem teaches you that mathematical structure (formulas, multiplicative properties) can dramatically improve algorithm efficiency over brute force.

## Examples

**Example 1:**

- Input: `k = 5`
- Output: `28`
- Explanation: T(7) = 28 has divisors {1, 2, 4, 7, 14, 28}, which is 6 divisors. This is the first triangular number with more than 5 divisors.

**Example 2:**

- Input: `k = 500`
- Output: `76576500`
- Explanation: This is the first triangular number with more than 500 divisors (it has 576 divisors).

## Constraints

- 1 <= k <= 500
- The answer will fit in a 64-bit signed integer

## Think About

1. How do you generate triangular numbers efficiently?
2. How do you count divisors of a number?
3. Can you use the formula T(n) = n × (n+1) / 2 to optimize divisor counting?
4. What properties do n and (n+1) have that you can exploit?

---

## Approach Hints

<details>
<summary>Hint 1: Generating Triangular Numbers and Counting Divisors</summary>

**Generating triangular numbers:**
- Use the formula: T(n) = n × (n + 1) / 2
- Or iteratively: T(n) = T(n-1) + n, starting with T(1) = 1

**Counting divisors (naive approach):**
```
count_divisors(n):
    count = 0
    for i from 1 to n:
        if n % i == 0:
            count += 1
    return count
```

**Optimization:** Only check up to √n. For each divisor i found, you also have n/i as a divisor.
```
count_divisors(n):
    count = 0
    i = 1
    while i * i <= n:
        if n % i == 0:
            count += 1  # Found divisor i
            if i * i != n:
                count += 1  # Also count n/i (unless i = sqrt(n))
        i += 1
    return count
```

**Time complexity:** O(√n) per triangular number. For large triangular numbers, this is still slow.

</details>

<details>
<summary>Hint 2: Using the Triangular Number Formula</summary>

Key insight: T(n) = n × (n + 1) / 2

**Important property:** gcd(n, n+1) = 1 (consecutive integers are coprime)

This means either:
- n is even and (n+1) is odd: T(n) = (n/2) × (n+1)
- n is odd and (n+1) is even: T(n) = n × ((n+1)/2)

**Multiplicative property of divisor count:**
If gcd(a, b) = 1, then d(a × b) = d(a) × d(b).

**Strategy:**
1. If n is even: d(T(n)) = d(n/2) × d(n+1)
2. If n is odd: d(T(n)) = d(n) × d((n+1)/2)

This splits the problem into counting divisors of two smaller numbers!

**Example: T(7) = 28**
- n = 7 (odd), so T(7) = 7 × (8/2) = 7 × 4
- d(28) = d(7) × d(4) = 2 × 3 = 6 ✓

</details>

<details>
<summary>Hint 3: Efficient Divisor Counting via Prime Factorization</summary>

**Divisor formula from prime factorization:**

If n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then:

d(n) = (a₁ + 1) × (a₂ + 1) × ... × (aₖ + 1)

**Example:** 28 = 2² × 7¹
- d(28) = (2 + 1) × (1 + 1) = 3 × 2 = 6

**Implementation:**
```
count_divisors_via_factorization(n):
    if n == 1: return 1

    count = 1
    # Extract factor 2
    exponent = 0
    while n % 2 == 0:
        exponent += 1
        n = n / 2
    count *= (exponent + 1)

    # Extract odd factors
    factor = 3
    while factor * factor <= n:
        exponent = 0
        while n % factor == 0:
            exponent += 1
            n = n / factor
        count *= (exponent + 1)
        factor += 2

    # If n > 1, it's a prime factor with exponent 1
    if n > 1:
        count *= 2  # (1 + 1)

    return count
```

**Complete algorithm:**
```
n = 1
while True:
    if n % 2 == 0:
        divisors = count_divisors(n / 2) * count_divisors(n + 1)
    else:
        divisors = count_divisors(n) * count_divisors((n + 1) / 2)

    if divisors > k:
        return n * (n + 1) / 2

    n += 1
```

</details>

---

## Complexity Analysis

| Approach | Time | Space | Trade-off |
|----------|------|-------|-----------|
| Naive (count divisors of T(n)) | O(T × √T) | O(1) | T = answer; very slow for large k |
| Optimized (split T(n) = a × b) | O(T × √a) | O(1) | Much faster; a ≈ √T |
| Precompute divisor counts | O(T log log T) | O(T) | Fastest; uses sieve-like approach |

**Where T is the index of the answer (e.g., T ≈ 12,000 for k = 500).**

**Why the optimized approach is better:**
- Without optimization: count divisors of T(n) ≈ √(n²) = n per iteration
- With optimization: count divisors of n and (n+1) ≈ √n each
- Speedup: roughly √n faster!

---

## Key Concept

**Divisor Counting and Multiplicative Functions**

**Divisor count formula:**

For n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ:

d(n) = (a₁ + 1) × (a₂ + 1) × ... × (aₖ + 1)

**Why this works:**
- Each divisor is formed by choosing exponents e₁, e₂, ..., eₖ where 0 ≤ eᵢ ≤ aᵢ
- For p₁^a₁, you have (a₁ + 1) choices: p₁⁰, p₁¹, ..., p₁^a₁
- Total divisors = product of choices for each prime

**Example: 60 = 2² × 3¹ × 5¹**
- d(60) = (2+1) × (1+1) × (1+1) = 3 × 2 × 2 = 12
- Divisors: {1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60} — indeed 12!

**Multiplicative property:**

If gcd(a, b) = 1, then d(a × b) = d(a) × d(b).

**Proof sketch:** The prime factorizations of a and b share no common primes. So the divisors of a × b are all products of a divisor of a with a divisor of b. The number of such products is d(a) × d(b).

**Application to triangular numbers:**

T(n) = n × (n+1) / 2

Since gcd(n, n+1) = 1 (consecutive numbers are coprime):
- If n is even: T(n) = (n/2) × (n+1), and gcd(n/2, n+1) = 1
- If n is odd: T(n) = n × ((n+1)/2), and gcd(n, (n+1)/2) = 1

So: d(T(n)) = d(smaller_part) × d(larger_part)

This splits the problem into two easier subproblems!

---

## Common Mistakes

1. **Counting divisors inefficiently**: Checking all numbers from 1 to n is O(n). Always optimize to O(√n) or use prime factorization.

2. **Not using the T(n) = n(n+1)/2 structure**: The fact that n and n+1 are coprime is the key optimization. Don't just generate T(n) and count its divisors naively.

3. **Integer division issues**: When computing n/2 or (n+1)/2, ensure you're checking n % 2 correctly to determine which is even.

4. **Off-by-one in divisor counting**: When i² = n, count i only once, not twice. Handle perfect squares carefully.

5. **Overflow in computing T(n)**: For large n, n × (n+1) / 2 can overflow. Compute carefully or use 64-bit integers.

---

## Variations

| Variation | Change | Approach Adjustment |
|-----------|--------|---------------------|
| First triangular with exactly k divisors | Exact count, not "more than" | Change comparison to `divisors == k` |
| Sum of divisors exceeds threshold | Sum divisors, not count | Use σ(n) formula: sum = Π((p^(a+1) - 1)/(p - 1)) |
| nth triangular number | Just compute T(n) | Use formula T(n) = n(n+1)/2 directly |
| Triangular numbers that are perfect squares | T(n) is a perfect square | Solve Pell equation 8x² + 1 = y² |
| List all divisors | Return list, not count | Collect divisors during factorization |

**Sum of divisors formula:**

If n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ:

σ(n) = Π((pᵢ^(aᵢ+1) - 1) / (pᵢ - 1))

**Example: 28 = 2² × 7¹**
- σ(28) = ((2³ - 1)/(2 - 1)) × ((7² - 1)/(7 - 1))
- σ(28) = (7/1) × (48/6) = 7 × 8 = 56
- Divisors: 1 + 2 + 4 + 7 + 14 + 28 = 56 ✓

---

## Practice Checklist

**Correctness:**

- [ ] Handles basic case (k = 5 returns 28)
- [ ] Handles larger case (k = 500)
- [ ] Correctly generates triangular numbers
- [ ] Correctly counts divisors

**Understanding:**

- [ ] Can explain the triangular number formula
- [ ] Understands the divisor count formula from prime factorization
- [ ] Can explain why gcd(n, n+1) = 1
- [ ] Understands the multiplicative property d(ab) = d(a)d(b) when gcd(a,b)=1

**Mastery:**

- [ ] Solved without hints
- [ ] Implemented optimized divisor counting
- [ ] Can derive the divisor formula from scratch
- [ ] Can extend to sum of divisors

**Spaced Repetition Tracker:**

- [ ] Day 1: Initial solve
- [ ] Day 3: Solve without hints
- [ ] Day 7: Implement variation (sum of divisors)
- [ ] Day 14: Explain multiplicative functions concept

---

**Euler Reference:** [Problem 12](https://projecteuler.net/problem=12)

**Next Step:** After mastering this, try [F016: Counting Divisors](./F016_counting_divisors.md)
