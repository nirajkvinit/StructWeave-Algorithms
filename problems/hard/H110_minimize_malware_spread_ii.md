---
id: H110
old_id: A395
slug: minimize-malware-spread-ii
title: Minimize Malware Spread II
difficulty: hard
category: hard
topics: ["graph"]
patterns: []
estimated_time_minutes: 45
strategy_ref: ../strategies/data-structures/graphs.md
---
# Minimize Malware Spread II

## Problem

Consider a network of `n` nodes represented by an `n x n` adjacency matrix `graph`. A value of `graph[i][j] == 1` indicates nodes `i` and `j` share a direct connection.

A set of nodes `initial` begins as contaminated. Contamination spreads along connections: whenever two directly connected nodes exist and one is contaminated, both become contaminated. This spreading process continues until reaching equilibrium.

Define `M(initial)` as the final count of contaminated nodes after spreading completes. Your task is to eliminate **exactly one node** from `initial`, which means **completely removing the node and all its connections** from the network.

Identify which node's removal would minimize `M(initial)`. If multiple candidates produce the same minimal result, select the one with the **smallest index**.

## Why This Matters

Graph problems model real-world networks and relationships. This builds your ability to explore connected structures systematically.

## Examples

**Example 1:**
- Input: `graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]`
- Output: `0`

**Example 2:**
- Input: `graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]`
- Output: `1`

**Example 3:**
- Input: `graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]`
- Output: `1`

## Constraints

- n == graph.length
- n == graph[i].length
- 2 <= n <= 300
- graph[i][j] is 0 or 1.
- graph[i][j] == graph[j][i]
- graph[i][i] == 1
- 1 <= initial.length <Â n
- 0 <= initial[i] <= n - 1
- All the integers in initial are **unique**.

## Think About

1. What makes this problem challenging? What's the core difficulty?
2. Can you identify subproblems? Do they overlap?
3. What invariants must be maintained?
4. Is there a mathematical relationship to exploit?

**Strategy**: See [Graph Pattern](../strategies/data-structures/graphs.md)

## Approach Hints

<details>
<summary>ðŸ”‘ Key Insight</summary>

The key is understanding that removing a node prevents contamination from spreading through it. For each initially contaminated node, find all clean nodes it would contaminate (its reachable component without other initial nodes). The best node to remove is the one that uniquely contaminates the most nodes - if multiple initial nodes can reach a component, removing one won't help.

</details>

<details>
<summary>ðŸŽ¯ Main Approach</summary>

Use BFS/DFS from each clean node to find which initial contaminated nodes can reach it (stop BFS when hitting any initial node). Group clean nodes by which initial nodes can reach them. For each initial node, count how many clean nodes are reachable ONLY by that node (not by other initial nodes). Remove the initial node with the highest unique contamination count. If tied, choose smallest index.

</details>

<details>
<summary>âš¡ Optimization Tip</summary>

Instead of running BFS from each initial node (which might double-count shared components), run BFS from each clean node to find which initial nodes can reach it. This naturally handles the case where multiple initial nodes contaminate the same component, and makes counting unique contaminations straightforward.

</details>

## Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force Simulation | O(n^2 * m) | O(n^2) | Simulate removal of each initial node |
| Optimal BFS from Clean | O(n * (n + e)) | O(n^2) | n = nodes, e = edges, BFS from each clean node |
| Optimized with Union-Find | O(n * Î±(n)) | O(n) | Using union-find for component tracking |

## Common Mistakes

1. **Not handling nodes reachable by multiple initial nodes**
   ```python
   # Wrong: Counting all reachable nodes for each initial node
   def count_saved(initial_node):
       visited = set([initial_node])
       count = 0
       # BFS from initial_node
       for neighbor in graph[initial_node]:
           count += 1  # Wrong! May be reachable from other initial nodes
       return count

   # Correct: Only count nodes uniquely reachable
   def count_saved(initial_node):
       # For each clean node, check if ONLY this initial node reaches it
       unique_count = 0
       for clean_node in clean_nodes:
           reachable_from = find_reachable_initial_nodes(clean_node)
           if reachable_from == {initial_node}:  # Uniquely saved
               unique_count += 1
       return unique_count
   ```

2. **Including initial nodes in contamination count**
   ```python
   # Wrong: Counting initial nodes themselves as contaminated
   total = len(initial) + len(contaminated_clean_nodes)

   # Correct: Only count clean nodes that become contaminated
   total = len(contaminated_clean_nodes)
   # Initial nodes are already contaminated, don't double count
   ```

3. **Not removing the node and its edges correctly**
   ```python
   # Wrong: Just marking node as uncontaminated but keeping edges
   def simulate_removal(node):
       initial.remove(node)
       contaminated = bfs_from_initial()  # Node still has edges!

   # Correct: Completely remove node from graph
   def simulate_removal(node):
       # Remove node means removing it and all its connections
       temp_graph = copy graph without node and its edges
       contaminated = bfs_from_initial(temp_graph)
   ```

## Variations

| Variation | Difficulty | Key Difference |
|-----------|------------|----------------|
| Minimize Malware I | Hard | Can only remove from initial, node stays in graph |
| K-Node Removal | Hard | Remove k nodes instead of 1 |
| Malware with Probability | Hard | Contamination spreads with certain probability |
| Weighted Malware Spread | Hard | Different nodes have different contamination weights |

## Practice Checklist

- [ ] Solved without hints
- [ ] Optimal time complexity achieved
- [ ] Clean, readable code
- [ ] Handled all edge cases (single initial node, all nodes initial, disconnected components)
- [ ] Can explain approach clearly

**Spaced Repetition:** Review in 1 day â†’ 3 days â†’ 7 days â†’ 14 days â†’ 30 days

---
**Strategy Reference:** [Graph BFS/DFS Pattern](../../strategies/patterns/breadth-first-search.md)
