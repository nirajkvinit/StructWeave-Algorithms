---
id: E117
old_id: I112
slug: super-ugly-number
title: Super Ugly Number
difficulty: easy
category: easy
topics: ["array", "math"]
patterns: ["dynamic-programming", "heap"]
estimated_time_minutes: 15
frequency: medium
related_problems: ["E058", "E059", "M001"]
prerequisites: ["arrays", "heap-operations", "dynamic-programming"]
strategy_ref: ../strategies/patterns/dynamic-programming.md
---
# Super Ugly Number

## Problem

A super ugly number is any positive integer whose only prime factors come from a given list of primes. For example, if the prime list is [2, 7, 13, 19], then 1 is a super ugly number (no prime factors), 2 is a super ugly number (only factor is 2), 14 is a super ugly number (2 × 7), but 3 is not (contains prime factor 3, which isn't in the list).

Your task is to find the nth super ugly number given a positive integer `n` and an array `primes` containing the allowed prime factors.

Think of super ugly numbers as being generated by repeatedly multiplying existing super ugly numbers by the allowed primes. You start with 1 (the first super ugly number), then generate 2, 4, 7, 8, 13, 14, 16... by multiplying previous super ugly numbers by primes from the list. The challenge is generating them in sorted order without duplicates and without checking every integer to see if it qualifies.

The elegant solution uses dynamic programming with multiple pointers, similar to merging k sorted lists. Maintain a pointer for each prime, tracking which super ugly number that prime should multiply next. At each step, select the minimum candidate across all primes, add it to your result, and advance the pointer(s) that produced that minimum. This ensures you generate super ugly numbers in ascending order.

A critical detail: when multiple primes generate the same candidate value, you must advance all their pointers simultaneously to avoid duplicates. For example, if both 2×2 and 4×1 produce 4, incrementing only one pointer would generate 4 again later.

## Why This Matters

The super ugly number problem generalizes the classic "ugly number" problem and demonstrates the powerful technique of using multiple pointers to merge sorted sequences. This pattern appears in external sorting algorithms, merging sorted files, and database query optimization when combining results from multiple indexes.

The dynamic programming approach here builds each answer from previous answers, a fundamental concept in memoization and optimal substructure. This same principle powers algorithms for shortest paths, edit distance, and resource allocation problems.

Understanding how to avoid duplicates through synchronized pointer advancement is crucial for data deduplication, stream processing systems, and time-series database queries where multiple sources may produce the same timestamp.

The choice between heap-based and pointer-based approaches teaches you to analyze tradeoffs between code simplicity and performance. The heap approach is more intuitive but slower due to logarithmic insertion; the pointer approach is faster but requires more careful bookkeeping.

## Examples

**Example 1:**
- Input: `n = 12, primes = [2,7,13,19]`
- Output: `32`
- Explanation: The first 12 super ugly numbers using primes [2,7,13,19] are: [1,2,4,7,8,13,14,16,19,26,28,32]

**Example 2:**
- Input: `n = 1, primes = [2,3,5]`
- Output: `1`
- Explanation: The number 1 contains no prime factors, so it trivially satisfies the condition with primes [2,3,5]

## Constraints

- 1 <= n <= 10⁵
- 1 <= primes.length <= 100
- 2 <= primes[i] <= 1000
- primes[i] is **guaranteed** to be a prime number.
- All the values of primes are **unique** and sorted in **ascending order**.

## Think About

1. What's the brute force approach? Why is it inefficient?
2. What property of the input can you exploit?
3. Would sorting or preprocessing help?
4. Can you reduce this to a problem you've seen before?

## Approach Hints

### Hint 1: Intuition (Beginner)
Think about how ugly numbers are generated. Each new ugly number is formed by multiplying an existing ugly number by one of the primes. Start with 1 (the first ugly number), then systematically generate larger ugly numbers by multiplying by each prime. The challenge is generating them in sorted order without duplicates.

### Hint 2: Optimization (Intermediate)
Maintain pointers for each prime, tracking which ugly number each prime should multiply next. At each step, pick the smallest candidate among all primes. This is similar to merging k sorted lists. Use dynamic programming to build the sequence: each ugly number builds on previously computed ones.

### Hint 3: Implementation Details (Advanced)
Use either a min-heap approach or a DP array with index pointers. For the DP approach: maintain an array of ugly numbers and k pointers (one per prime). At each step, compute candidates[i] = ugly[pointers[i]] * primes[i], find the minimum, add it to the result, and advance all pointers that produced this minimum to handle duplicates.

## Complexity Analysis

| Approach | Time Complexity | Space Complexity | Notes |
|----------|----------------|------------------|-------|
| Min-heap approach | O(n * k * log(n*k)) | O(n*k) | Each insertion/extraction is log(heap_size) |
| DP with pointers | O(n * k) | O(n) | Check k primes for each of n numbers |
| Optimized DP | O(n * k) | O(n) | Efficient pointer management, no duplicates |
| Brute force (check all) | O(n * m * log(primes)) | O(1) | Check every number m until finding n ugly numbers |

## Common Mistakes

### Mistake 1: Not Handling Duplicates
```python
# Wrong: Can generate the same number multiple ways
def nthSuperUglyNumber(n, primes):
    ugly = [1]
    for i in range(n-1):
        candidates = [ugly[-1] * p for p in primes]
        ugly.append(min(candidates))  # Creates duplicates!
    return ugly[-1]
```
**Fix:** After selecting the minimum, advance ALL pointers that generated that value to avoid duplicates.

### Mistake 2: Starting Pointers Incorrectly
```python
# Wrong: All pointers start at wrong position
def nthSuperUglyNumber(n, primes):
    pointers = [1] * len(primes)  # Should start at 0!
    ugly = [1]
```
**Fix:** All pointers should start at index 0, pointing to the first ugly number (1).

### Mistake 3: Inefficient Heap Usage
```python
# Wrong: Keeping too many elements in heap
def nthSuperUglyNumber(n, primes):
    heap = [1]
    for num in heap:  # Heap grows unbounded
        for p in primes:
            heappush(heap, num * p)
```
**Fix:** Only maintain necessary candidates, remove duplicates, or use the DP pointer approach.

## Variations

| Variation | Description | Difficulty | Key Difference |
|-----------|-------------|------------|----------------|
| Ugly Number (2,3,5 only) | Fixed set of 3 primes | Easy | Simpler case, fewer pointers |
| Ugly Number II | Find if number is ugly | Easy | Division-based checking |
| Hamming Numbers | Same as ugly number | Easy | Different name, same concept |
| K-th Factor Number | Any k factors, not just primes | Medium | More general factor set |

## Practice Checklist

Study Plan:
- [ ] Day 1: Understand ugly number generation, implement brute force
- [ ] Day 3: Implement DP with pointers, handle duplicates correctly
- [ ] Day 7: Optimize pointer management, solve without hints
- [ ] Day 14: Implement heap approach, compare trade-offs
- [ ] Day 30: Speed solve (< 15 minutes), explain to someone

Key Mastery Indicators:
- Can explain why pointers prevent recomputation
- Handle duplicate generation correctly
- Choose between heap and DP approaches based on constraints
- Understand connection to merge k sorted lists

**Strategy**: See [Dynamic Programming](../strategies/patterns/dynamic-programming.md)
