---
id: E013
old_id: F018
slug: 4sum
title: 4Sum
difficulty: easy
category: easy
topics: ["array", "two-pointers", "sorting"]
patterns: ["two-pointers", "k-sum"]
estimated_time_minutes: 15
frequency: medium
related_problems: ["E001", "E011", "M015"]
prerequisites: ["two-pointers", "sorting-algorithms", "duplicate-handling"]
strategy_ref: ../../strategies/patterns/two-pointers.md
---
# 4Sum

## Problem

Given an array of integers and a target value, find all unique combinations of four numbers that add up to the target. Each combination should appear only once in your result, regardless of how many times those numbers appear in the array.

For example, in the array `[1, 0, -1, 0, -2, 2]` with target `0`, you would find quadruplets like `[-2, -1, 1, 2]`, `[-2, 0, 0, 2]`, and `[-1, 0, 0, 1]`. Notice that even though some numbers like `0` appear multiple times, each unique combination is reported only once.

This extends the 3Sum problem by adding another dimension of complexity. While you could check all possible combinations of four numbers, that would require four nested loops and be prohibitively slow for larger arrays. The challenge is finding an efficient approach that leverages sorting and the two-pointer technique to reduce unnecessary comparisons while carefully avoiding duplicate quadruplets.

## Why This Matters

This problem demonstrates the k-Sum pattern, showing how algorithmic patterns scale as problems grow in complexity. By fixing two elements and using two pointers for the remaining pair, you reduce a four-dimensional search space to a more manageable problem.

This pattern appears in financial portfolio optimization (finding combinations of assets meeting criteria), scientific computing (identifying molecule combinations with specific properties), and data mining (discovering correlated feature sets). Understanding how to generalize from 2Sum to 3Sum to 4Sum teaches you to recognize and extend algorithmic patterns, a critical skill for tackling novel problems.

## Examples

**Example 1:**
- Input: `nums = [1,0,-1,0,-2,2], target = 0`
- Output: `[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`

**Example 2:**
- Input: `nums = [2,2,2,2,2], target = 8`
- Output: `[[2,2,2,2]]`

## Constraints

- 1 <= nums.length <= 200
- -10‚Åπ <= nums[i] <= 10‚Åπ
- -10‚Åπ <= target <= 10‚Åπ

## Think About

1. What's the brute force approach? What's its time complexity?
2. Can you identify any patterns in the examples?
3. What data structure would help organize the information?

## Approach Hints

<details>
<summary>üí° Hint 1: Reduce to 2Sum</summary>

This is an extension of the 2Sum and 3Sum patterns. The key insight: Fix two elements, then use the two-pointer technique to find the remaining two elements.

Think about the structure:
- Fix first element at index i
- Fix second element at index j (where j > i)
- Use two pointers to find remaining two elements that sum to (target - nums[i] - nums[j])

What preprocessing helps? How do you avoid duplicates?

</details>

<details>
<summary>üéØ Hint 2: Sort + Nested Loops + Two Pointers</summary>

1. Sort the array first to enable two-pointer technique
2. Use two nested loops to fix the first two numbers
3. For each pair (i, j), use two pointers (left, right) to find the other two numbers
4. Skip duplicates at all levels to ensure unique quadruplets

**Duplicate handling is critical:**
- Skip duplicate values for i
- Skip duplicate values for j
- Skip duplicate values for left and right pointers

</details>

<details>
<summary>üìù Hint 3: Complete Algorithm</summary>

**Pseudocode:**
```
1. Sort nums
2. Initialize result = []
3. For i from 0 to n-4:
   a. Skip if nums[i] == nums[i-1] (avoid duplicate quadruplets)
   b. For j from i+1 to n-3:
      - Skip if nums[j] == nums[j-1] (for j > i+1)
      - target_sum = target - nums[i] - nums[j]
      - left = j + 1, right = n - 1
      - While left < right:
        * current_sum = nums[left] + nums[right]
        * If current_sum == target_sum:
          - Add [nums[i], nums[j], nums[left], nums[right]]
          - Skip duplicates for left: while left < right and nums[left] == nums[left+1]: left++
          - Skip duplicates for right: while left < right and nums[right] == nums[right-1]: right--
          - left++, right--
        * Else if current_sum < target_sum:
          - left++
        * Else:
          - right--
4. Return result
```

**Optimization:** Early termination if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target

</details>

## Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force | O(n‚Å¥) | O(1) | Check all 4-tuples |
| Hash Map (pairs) | O(n¬≤) | O(n¬≤) | Store all pairs, check complements |
| **Sort + Two Pointers** | **O(n¬≥)** | **O(1) or O(n)** | Two nested loops + two pointers |

Space complexity: O(1) if sorting in-place, O(n) if creating sorted copy

## Common Mistakes

### 1. Not handling duplicates correctly
```python
# WRONG: Generates duplicate quadruplets
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        # ... two pointer logic ...
# Gives duplicates like [-2,-1,1,2] multiple times

# CORRECT: Skip duplicates at each level
for i in range(len(nums)):
    if i > 0 and nums[i] == nums[i-1]:
        continue
    for j in range(i+1, len(nums)):
        if j > i+1 and nums[j] == nums[j-1]:
            continue
```

### 2. Wrong loop bounds
```python
# WRONG: Not leaving enough room for remaining elements
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        left, right = j+1, len(nums)-1
# When i = n-1, there's no room for j, left, right

# CORRECT: Proper bounds to ensure 4 elements
for i in range(len(nums) - 3):
    for j in range(i+1, len(nums) - 2):
        left, right = j+1, len(nums)-1
```

### 3. Integer overflow (for large values)
```python
# WRONG: Might overflow with large numbers
if nums[i] + nums[j] + nums[left] + nums[right] == target:

# CORRECT: Compute in steps or use careful comparison
target_sum = target - nums[i] - nums[j]
if nums[left] + nums[right] == target_sum:
```

### 4. Incorrect duplicate skipping in two-pointer section
```python
# WRONG: Skips too many elements
if nums[left] + nums[right] == target_sum:
    result.append([nums[i], nums[j], nums[left], nums[right]])
    while nums[left] == nums[left+1]:  # Can go out of bounds!
        left += 1

# CORRECT: Check bounds while skipping
while left < right and nums[left] == nums[left+1]:
    left += 1
while left < right and nums[right] == nums[right-1]:
    right -= 1
left += 1
right -= 1
```

## Variations

| Variation | Change | Approach Adjustment |
|-----------|--------|---------------------|
| 3Sum | Three numbers instead of four | Remove one outer loop, O(n¬≤) |
| kSum | k numbers | Generalize with recursion or k-2 loops |
| Count quadruplets | Count instead of list | Don't store results, just count |
| 4Sum II (different arrays) | Four different arrays | Use hash map, different approach |
| 4Sum smaller than target | All sums < target | Count while doing two pointers |
| Quadruplets with product | Multiplication instead of sum | Similar structure, different operation |

## Practice Checklist

**Correctness:**
- [ ] Handles exactly 4 elements
- [ ] Handles arrays with duplicates
- [ ] Handles negative numbers
- [ ] Handles zero target
- [ ] Returns unique quadruplets only
- [ ] Handles large values (no overflow)

**Interview Readiness:**
- [ ] Can explain approach in 2 minutes
- [ ] Can code solution in 15-18 minutes
- [ ] Can discuss complexity
- [ ] Can explain duplicate handling at each level
- [ ] Can generalize to kSum problem

**Spaced Repetition Tracker:**
- [ ] Day 1: Initial solve
- [ ] Day 3: Solve without hints
- [ ] Day 7: Solve variations (3Sum, kSum)
- [ ] Day 14: Explain to someone
- [ ] Day 30: Quick review

---

**Strategy**: See [Two Pointers Pattern](../../strategies/patterns/two-pointers.md)
