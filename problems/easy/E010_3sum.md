---
id: E010
old_id: F015
slug: 3sum
title: 3Sum
difficulty: easy
category: easy
topics: ["array", "two-pointers", "sorting"]
patterns: ["two-pointers", "duplicate-handling"]
estimated_time_minutes: 25
frequency: very-high
related_problems: ["E001", "E013", "M018"]
prerequisites: ["arrays-basics", "two-pointers-pattern", "sorting"]
---
# 3Sum

## Problem

Given an array of integers, find all unique combinations of three numbers that add up to zero. Each combination should appear only once in your result, even if the same three numbers appear multiple times in the array.

For example, in the array `[-1, 0, 1, 2, -1, -4]`, the triplets `[-1, -1, 2]` and `[-1, 0, 1]` both sum to zero. Notice that even though `-1` appears twice, we only report the unique combination `[-1, -1, 2]` once.

The order of triplets in your answer does not matter, and within each triplet, the order of numbers does not matter either. The key challenge is efficiently finding all such triplets while avoiding duplicates, which requires more than just checking every possible combination of three numbers.

## Why This Matters

This problem combines multiple fundamental techniques: **sorting + two pointers + duplicate elimination**. It's a staple interview question that tests your ability to optimize brute force solutions and handle edge cases.

**Real-world applications:**
- **Chemistry**: Finding molecular compound combinations with specific properties
- **Finance**: Portfolio balancing - finding asset combinations that neutralize risk
- **Cryptography**: Subset sum problems in hash collision detection
- **Data analysis**: Anomaly detection by finding correlated data point triplets

**Core skills developed:**
- **Problem decomposition**: Reducing 3Sum to multiple 2Sum subproblems
- **Duplicate handling**: Managing duplicate results in combinatorial problems
- **Trade-off reasoning**: Sorting cost vs. search efficiency

## Examples

**Example 1:**
- Input: `nums = [-1,0,1,2,-1,-4]`
- Output: `[[-1,-1,2],[-1,0,1]]`
- Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.

**Example 2:**
- Input: `nums = [0,1,1]`
- Output: `[]`
- Explanation: The only possible triplet does not sum up to 0.

**Example 3:**
- Input: `nums = [0,0,0]`
- Output: `[[0,0,0]]`
- Explanation: The only possible triplet sums up to 0.

## Constraints

- 3 <= nums.length <= 3000
- -10‚Åµ <= nums[i] <= 10‚Åµ

## Think About

1. How is this problem related to Two Sum (E001)? Can you fix one element and solve Two Sum on the rest?
2. If the array were sorted, how would that help identify duplicates?
3. For a sorted array [-4, -1, -1, 0, 1, 2], after finding triplet [-1, -1, 2], how do you avoid finding it again?
4. What's the time complexity of checking all triplets? Can sorting help reduce this?

---

## Approach Hints

<details>
<summary>üí° Hint 1: How many triplets are there?</summary>

The brute force approach uses three nested loops to check every possible triplet:
```
for i in range(n):
    for j in range(i+1, n):
        for k in range(j+1, n):
            if nums[i] + nums[j] + nums[k] == 0:
                add to result
```

This is O(n¬≥) time complexity. With n up to 3000, that's up to 27 billion operations!

**Think about:** Can you reduce the number of elements you check for the third element?

</details>

<details>
<summary>üéØ Hint 2: Reduce 3Sum to 2Sum</summary>

**Key insight:** If you fix one number, you can use Two Sum on the remaining array!

For each element `nums[i]`, find all pairs in the rest of the array that sum to `-nums[i]`.

**But how to find pairs efficiently?**
- Sorting the array lets you use **two pointers** for the Two Sum part
- This reduces inner complexity from O(n¬≤) to O(n)
- Total: O(n¬≤) time

**Handling duplicates:** In a sorted array, skip consecutive duplicate values:
```
[-4, -1, -1, -1, 0, 1, 2]
     ^   ^   ^
     skip these after processing first -1
```

</details>

<details>
<summary>üìù Hint 3: Sort + Two Pointers algorithm</summary>

```
sort the array
result = []

for i from 0 to n-3:
    # Skip duplicate values for first element
    if i > 0 and nums[i] == nums[i-1]:
        continue

    # Two Sum on nums[i+1:] with target = -nums[i]
    left = i + 1
    right = n - 1
    target = -nums[i]

    while left < right:
        current_sum = nums[left] + nums[right]

        if current_sum == target:
            result.append([nums[i], nums[left], nums[right]])

            # Skip duplicates for second element
            while left < right and nums[left] == nums[left+1]:
                left += 1
            # Skip duplicates for third element
            while left < right and nums[right] == nums[right-1]:
                right -= 1

            left += 1
            right -= 1

        elif current_sum < target:
            left += 1
        else:
            right -= 1

return result
```

**Why this works:**
- Sorting: O(n log n)
- Outer loop: O(n)
- Inner two pointers: O(n) per iteration
- Total: O(n¬≤)

</details>

---

## Complexity Analysis

| Approach | Time | Space | Trade-off |
|----------|------|-------|-----------|
| Brute Force | O(n¬≥) | O(1) | Check all triplets; impractical for n=3000 |
| Hash Set (unsorted) | O(n¬≤) | O(n) | Fix one, use hash for pairs; complex duplicate handling |
| **Sort + Two Pointers** | **O(n¬≤)** | **O(log n) to O(n)** | Optimal time; space for sorting |

**Why Sort + Two Pointers Wins:**
- Sorting enables efficient duplicate skipping
- Two pointers reduces pair search from O(n¬≤) to O(n)
- Total O(n¬≤) time is provably optimal (must examine each pair at least once)
- Space complexity is just sorting overhead (O(log n) to O(n) depending on sort algorithm)

---

## Common Mistakes

### 1. Not skipping duplicates correctly
```
# WRONG: Checking against next element causes infinite loop
if nums[i] == nums[i+1]:
    continue

# CORRECT: Check against previous element
if i > 0 and nums[i] == nums[i-1]:
    continue
```

### 2. Forgetting to skip duplicates for all three positions
```
# WRONG: Only skipping first element
for i in range(n):
    if i > 0 and nums[i] == nums[i-1]:
        continue
    # ... but not skipping left/right duplicates

# CORRECT: Skip duplicates at all three positions
# (see Hint 3 for complete code)
```

### 3. Not sorting the array first
```
# WRONG: Two pointers require sorted array!
result = []
for i in range(n):
    left, right = i+1, n-1
    # This doesn't work on unsorted array

# CORRECT: Sort first
nums.sort()
```

### 4. Including duplicate triplets in different orders
```
# WRONG: Adding [1, -1, 0] and [-1, 0, 1] as separate results
result.append([nums[i], nums[left], nums[right]])  # No ordering check

# CORRECT: Sorting ensures consistent order, skip logic prevents duplicates
# After sorting, triplets naturally appear in order: [-1, 0, 1]
```

### 5. Off-by-one errors in duplicate skipping
```
# WRONG: Can cause index out of bounds
while left < right and nums[left] == nums[left+1]:
    left += 1
# If left reaches right, nums[left+1] is out of bounds!

# CORRECT: Check bounds first
while left < right and nums[left] == nums[left+1]:
    left += 1
```

---

## Variations

| Variation | Change | Approach Adjustment |
|-----------|--------|---------------------|
| **3Sum Closest (M016)** | Find triplet closest to target | Same structure, track min distance |
| **4Sum (E013)** | Find quadruplets summing to target | Add outer loop, becomes O(n¬≥) |
| **3Sum Smaller (M259)** | Count triplets with sum < target | Count instead of collect, adjust pointers |
| **3Sum with multiplicity** | Count considering duplicates | Combinatorics with frequency map |
| **No duplicates in input** | Array has unique elements | Simpler - no duplicate skipping needed |

**Generalization: k-Sum**
```
2-Sum: O(n) with hash map or O(n log n) with sort + two pointers
3-Sum: O(n¬≤) with sort + two pointers
4-Sum: O(n¬≥) with sort + two pointers
k-Sum: O(n^(k-1)) general case
```

---

## Practice Checklist

**Correctness:**
- [ ] Handles Example 1 (multiple triplets)
- [ ] Handles Example 2 (no solution)
- [ ] Handles Example 3 (all zeros)
- [ ] Handles array with duplicates: [-2,0,0,2,2]
- [ ] Handles negative, zero, positive mix
- [ ] Returns triplets in consistent order

**Optimization:**
- [ ] Achieved O(n¬≤) time complexity
- [ ] Space complexity is O(log n) to O(n) (sorting)
- [ ] No duplicate triplets in output
- [ ] Can explain why sorting helps

**Interview Readiness:**
- [ ] Can reduce 3Sum to 2Sum verbally
- [ ] Can explain duplicate skipping strategy
- [ ] Can code solution in 10 minutes
- [ ] Can derive time complexity from first principles
- [ ] Can discuss 4Sum extension

**Spaced Repetition Tracker:**
- [ ] Day 1: Initial solve
- [ ] Day 3: Solve without hints
- [ ] Day 7: Implement 4Sum variation
- [ ] Day 14: Explain duplicate handling to someone
- [ ] Day 30: Quick review

---

**Strategy**: See [Two Pointers Pattern](../../strategies/patterns/two-pointers.md) | [Sorting Techniques](../../strategies/fundamentals/sorting.md)
