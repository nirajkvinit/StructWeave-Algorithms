---
id: M512
old_id: A391
slug: minimize-malware-spread
title: Minimize Malware Spread
difficulty: medium
category: medium
topics: ["graph"]
patterns: []
estimated_time_minutes: 30
strategy_ref: ../prerequisites/graphs.md
---
# Minimize Malware Spread

## Problem

Imagine you're a cybersecurity analyst at a tech company. Your network has been compromised, and several computers are already infected with malware. The malware spreads automatically: whenever an infected computer connects to a clean one, the clean computer becomes infected too. This propagation continues until no more computers can be infected.

You have the ability to quarantine exactly one of the initially infected computers before the malware starts spreading. Your mission: choose which infected computer to isolate in order to minimize the total damage.

Given a network with `n` computers, represented by an `n x n` adjacency matrix `graph` where `graph[i][j] == 1` indicates a direct connection between computers `i` and `j`, and a list `initial` containing the initially infected computers, determine which one computer from `initial` you should quarantine to result in the fewest total infections.

The network is represented as follows:
- `graph[i][j] == 1` means computers `i` and `j` are directly connected
- A subset of computers `initial` starts as infected
- Infection propagates through connections: if computer A is infected and connected to computer B, then B becomes infected
- This continues until reaching a stable state

Your task: select exactly one computer from `initial` to quarantine. Return the index of the computer whose removal would minimize the final infection count `M(initial)`. If multiple computers produce the same minimal result, choose the one with the lowest index.

Important: quarantining a computer from `initial` doesn't guarantee it won't eventually get infected from another source if multiple infection points exist in its network segment.

## Why This Matters

This problem models critical real-world scenarios in network security, epidemiology, and infrastructure management. Security teams use similar analysis to prioritize which compromised servers to isolate during a breach. Public health officials apply these concepts to contain disease outbreaks by identifying super-spreaders. Cloud infrastructure engineers use graph connectivity analysis to prevent cascading failures in distributed systems. Understanding connected components and infection propagation teaches you to think strategically about network vulnerabilities and optimize resource allocation when you can only intervene in limited ways. The principle applies anywhere a problem spreads through connections: server crashes, social media misinformation, or supply chain disruptions.

## Examples

**Example 1:**
- Input: `graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]`
- Output: `0`

**Example 2:**
- Input: `graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]`
- Output: `0`

**Example 3:**
- Input: `graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]`
- Output: `1`

## Constraints

- n == graph.length
- n == graph[i].length
- 2 <= n <= 300
- graph[i][j] is 0 or 1.
- graph[i][j] == graph[j][i]
- graph[i][i] == 1
- 1 <= initial.length <= n
- 0 <= initial[i] <= n - 1
- All the integers in initial are **unique**.

## Think About

1. What makes this problem challenging? What's the core difficulty?
2. Can you identify subproblems? Do they overlap?
3. What invariants must be maintained?
4. Is there a mathematical relationship to exploit?

**Strategy**: See [Graph Pattern](../prerequisites/graphs.md)

## Approach Hints

<details>
<summary>ðŸ”‘ Key Insight</summary>
The graph forms connected components. If a component has exactly one initially infected node, removing it saves the entire component. If it has multiple infected nodes, removing one doesn't help that component. Use Union-Find or DFS to identify components and count infected nodes per component.
</details>

<details>
<summary>ðŸŽ¯ Main Approach</summary>
Use Union-Find to group nodes into connected components. For each component, count how many initially infected nodes it contains. A node is worth removing only if it's the sole infection source in its component - savings equal the component size. Choose the node with maximum savings, or lowest index if tied.
</details>

<details>
<summary>âš¡ Optimization Tip</summary>
Union-Find with path compression and union by rank runs in nearly O(1) amortized time. After building components, iterate through initial infected nodes and track which components have exactly one infected node. Sum up component sizes for maximum impact.
</details>

## Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| DFS per removal | O(nÂ² * m) | O(n) | Simulate each removal, too slow |
| Union-Find | O(nÂ² * Î±(n)) | O(n) | Î±(n) is inverse Ackermann, nearly constant |
| Optimal | O(nÂ² * Î±(n)) | O(n) | Build components once, analyze infections |

## Common Mistakes

1. **Not considering components with multiple infections**
   ```python
   # Wrong: Assumes removing any node helps
   def minMalwareSpread(self, graph, initial):
       n = len(graph)
       # Build components...
       max_save = 0
       result = min(initial)
       for node in initial:
           # Wrong: doesn't check if component has other infections
           save = component_size[find(node)]
           if save > max_save:
               max_save = save
               result = node
       return result

   # Correct: Only count if sole infection in component
   def minMalwareSpread(self, graph, initial):
       # ... union-find setup ...
       component_infected = collections.Counter()
       for node in initial:
           component_infected[find(node)] += 1

       max_save = 0
       result = min(initial)
       for node in initial:
           comp = find(node)
           if component_infected[comp] == 1:  # Only infection
               save = component_size[comp]
               if save > max_save or (save == max_save and node < result):
                   max_save = save
                   result = node
       return result
   ```

2. **Forgetting to return smallest index when tied**
   ```python
   # Wrong: May return larger index on tie
   max_save = 0
   result = initial[0]
   for node in initial:
       save = calculate_savings(node)
       if save > max_save:
           max_save = save
           result = node
   return result

   # Correct: Check index on equality
   max_save = 0
   result = min(initial)
   for node in initial:
       save = calculate_savings(node)
       if save > max_save or (save == max_save and node < result):
           max_save = save
           result = node
   return result
   ```

## Variations

| Variation | Difficulty | Key Difference |
|-----------|------------|----------------|
| Number of Connected Components | Medium | Just count components without infection logic |
| Redundant Connection | Medium | Find edge to remove to make tree |
| Minimize Malware Spread II | Hard | Can remove any node, not just initially infected |

## Practice Checklist

- [ ] Solved without hints
- [ ] Optimal time complexity achieved
- [ ] Clean, readable code
- [ ] Handled all edge cases
- [ ] Can explain approach clearly

**Spaced Repetition:** Review in 1 day â†’ 3 days â†’ 7 days â†’ 14 days â†’ 30 days

---
**Strategy Reference:** [Graphs](../../prerequisites/graphs.md)
