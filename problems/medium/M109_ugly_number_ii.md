---
id: M109
old_id: I063
slug: ugly-number-ii
title: Ugly Number II
difficulty: medium
category: medium
topics: ["dynamic-programming", "math", "heap"]
patterns: ["three-pointers", "merge-sorted-sequences"]
estimated_time_minutes: 30
frequency: medium
related_problems: ["E163", "M264", "M313"]
prerequisites: ["heap-operations", "dynamic-programming", "number-theory"]
---
# Ugly Number II

## Problem

An ugly number is a positive integer whose only prime factors are 2, 3, and 5. The sequence starts as 1, 2, 3, 4, 5, 6, 8, 9, 10, 12... Notice that 7 is missing because it contains a prime factor other than 2, 3, or 5. Your task is to find the nth ugly number efficiently. The naive approach of checking every number to see if it's ugly would be extremely slow for large n. Instead, think about how every ugly number (except 1) is generated by multiplying a previous ugly number by 2, 3, or 5. This suggests a dynamic programming approach where you build the sequence incrementally, maintaining three pointers to track which ugly number should be multiplied by 2, 3, and 5 next. At each step, you take the minimum of these three candidates, similar to merging sorted lists. Watch out for duplicates like 6, which can be generated as both 2√ó3 and 3√ó2, and make sure each pointer advances appropriately to avoid them.

## Why This Matters

Ugly number generation is a special case of the more general problem of generating sequences with specific mathematical properties, used in number theory and cryptography. In digital signal processing, numbers with small prime factors are preferred for FFT (Fast Fourier Transform) sizes because they enable efficient computation. Hardware designers favor these numbers for memory allocation sizes and buffer dimensions for similar efficiency reasons. The three-pointer merging technique you'll learn here applies broadly to problems involving multiple sorted sequences, like k-way merge in external sorting algorithms used by databases. Understanding how to generate sequences efficiently without checking every candidate is essential for optimization problems in competitive programming and real-world systems where precomputing sequences saves runtime. This dynamic programming pattern of building solutions from previously computed results is fundamental to memoization and efficient algorithm design.

## Examples

**Example 1:**
- Input: `n = 10`
- Output: `12`
- Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.

**Example 2:**
- Input: `n = 1`
- Output: `1`
- Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.

## Constraints

- 1 <= n <= 1690

## Think About

1. What's the brute force approach? Why is it inefficient?
2. What property of the input can you exploit?
3. Would sorting or preprocessing help?
4. Can you reduce this to a problem you've seen before?

## Approach Hints

<details>
<summary>üí° Hint 1: Building from Previous Ugly Numbers</summary>

Every ugly number (except 1) is formed by multiplying a previous ugly number by 2, 3, or 5. If you have the sequence [1, 2, 3, 4, 5, 6], the next ugly number must be one of {2√ó4, 3√ó3, 5√ó2} = {8, 9, 10}. How can you systematically generate them in order?

</details>

<details>
<summary>üéØ Hint 2: Three Pointer Technique</summary>

Maintain three pointers (i2, i3, i5) that track which ugly number should be multiplied by 2, 3, and 5 next. At each step, the next ugly number is min(ugly[i2]√ó2, ugly[i3]√ó3, ugly[i5]√ó5). After selecting the minimum, advance the corresponding pointer(s). This is like merging three sorted sequences.

</details>

<details>
<summary>üìù Hint 3: Dynamic Programming Implementation</summary>

```
1. Initialize dp array with dp[0] = 1
2. Create three pointers: p2 = p3 = p5 = 0
3. For i from 1 to n-1:
   - next2 = dp[p2] * 2
   - next3 = dp[p3] * 3
   - next5 = dp[p5] * 5
   - dp[i] = min(next2, next3, next5)
   - If dp[i] == next2: p2++
   - If dp[i] == next3: p3++
   - If dp[i] == next5: p5++
4. Return dp[n-1]
```

Note: Multiple pointers can advance simultaneously to avoid duplicates (e.g., 6 = 2√ó3 = 3√ó2).

</details>

## Complexity Analysis

| Approach | Time | Space | Notes |
|----------|------|-------|-------|
| Brute Force (Check each number) | O(n¬∑log m) | O(n) | Check if each number ‚â§ m is ugly |
| Min Heap | O(n¬∑log n) | O(n) | Generate candidates, use heap to get min |
| **Three Pointers (DP)** | **O(n)** | **O(n)** | Optimal, generates exactly n ugly numbers |

## Common Mistakes

### Mistake 1: Not handling duplicates
```python
# Wrong: May generate duplicates like 6 (2√ó3 and 3√ó2)
def nthUglyNumber(n):
    dp = [1]
    p2 = p3 = p5 = 0
    for i in range(1, n):
        next_num = min(dp[p2]*2, dp[p3]*3, dp[p5]*5)
        dp.append(next_num)
        if next_num == dp[p2]*2: p2 += 1
        elif next_num == dp[p3]*3: p3 += 1  # Wrong: use 'elif'
        elif next_num == dp[p5]*5: p5 += 1
    return dp[-1]

# Correct: Use independent if statements
def nthUglyNumber(n):
    dp = [1]
    p2 = p3 = p5 = 0
    for i in range(1, n):
        next_num = min(dp[p2]*2, dp[p3]*3, dp[p5]*5)
        dp.append(next_num)
        if next_num == dp[p2]*2: p2 += 1
        if next_num == dp[p3]*3: p3 += 1
        if next_num == dp[p5]*5: p5 += 1
    return dp[-1]
```

### Mistake 2: Inefficient brute force checking
```python
# Wrong: Checking every number is too slow
def isUgly(num):
    if num <= 0: return False
    for p in [2, 3, 5]:
        while num % p == 0:
            num //= p
    return num == 1

def nthUglyNumber(n):
    count, num = 0, 0
    while count < n:
        num += 1
        if isUgly(num):
            count += 1
    return num  # O(m¬∑log m) where m can be huge

# Correct: Generate, don't check
# Use three-pointer approach shown above
```

### Mistake 3: Heap approach with set bloat
```python
# Wrong: Set can grow very large
def nthUglyNumber(n):
    heap = [1]
    seen = {1}
    ugly = 1
    for _ in range(n):
        ugly = heapq.heappop(heap)
        for factor in [2, 3, 5]:
            new_ugly = ugly * factor
            if new_ugly not in seen:
                seen.add(new_ugly)
                heapq.heappush(heap, new_ugly)
    return ugly  # Set can have >> n elements

# Better: Use three-pointer DP (no extra space for set)
```

## Variations

| Variation | Difficulty | Key Difference |
|-----------|------------|----------------|
| Ugly Number I (check if number is ugly) | Easy | Single number validation |
| Super Ugly Number (k prime factors) | Medium | Generalize to k pointers |
| Hamming Numbers (same as ugly) | Medium | Different name, same concept |
| Numbers with prime factors in range | Hard | Handle variable prime set |
| Kth smallest in multiplication table | Hard | 2D version of merge concept |

## Practice Checklist

- [ ] **Day 0**: Solve using three-pointer DP (30 min)
- [ ] **Day 1**: Implement min-heap approach (25 min)
- [ ] **Day 3**: Code from memory, explain why duplicates need handling (20 min)
- [ ] **Day 7**: Solve Super Ugly Number variation (35 min)
- [ ] **Day 14**: Optimize space to O(1) using sliding window (30 min)
- [ ] **Day 30**: Speed run under time pressure (15 min)

**Strategy**: See [Dynamic Programming Patterns](../strategies/patterns/dynamic-programming.md)
