---
id: M326
old_id: A146
slug: 24-game
title: 24 Game
difficulty: medium
category: medium
topics: ["array", "math", "backtracking"]
patterns: ["backtrack-permutation"]
estimated_time_minutes: 30
frequency: low
related_problems: ["M282", "M494", "M842"]
prerequisites: ["backtracking", "permutations", "floating-point-arithmetic"]
---
# 24 Game

## Problem

Given four integers (each between 1 and 9), determine whether you can combine them using the operations +, -, ×, and ÷, along with parentheses, to produce exactly 24.

This is based on the classic card game where players race to find a valid expression. For example, with cards [4, 1, 8, 7], you can compute (8-4) × (7-1) = 4 × 6 = 24. The challenge is determining algorithmically whether any valid arrangement exists.

Several important rules constrain your solution:

- **Division is floating-point**: 4 ÷ (1 - 2/3) = 4 ÷ (1/3) = 12, not integer division
- **All operations are binary**: You must combine exactly two numbers at a time. You cannot use unary negation like -1
- **Digits cannot be concatenated**: With [1, 2, 1, 2], you cannot form "12 + 12"
- **All four numbers must be used**: You can't skip a number

The key algorithmic insight is that you're building an expression tree. Each operation combines two subtrees (or leaves), reducing four numbers to three, then to two, then to one final result. You need to explore all possible ways to pick two numbers, all four operations, and all valid orderings.

With only 4 numbers, the search space is manageable: roughly C(4,2) × 4 × C(3,2) × 4 × C(2,2) × 4 ≈ 1,152 combinations (choosing pairs times choosing operations). This makes backtracking feasible.

Be careful with floating-point comparison: when checking if your result equals 24, use an epsilon tolerance (like |result - 24| < 0.0001) to handle rounding errors.

## Why This Matters

This problem teaches exhaustive search with backtracking, a fundamental technique for exploring all possibilities in a structured way. The pattern of "pick two elements, combine them, recurse on the smaller problem" appears in expression parsing, game tree search, and combinatorial optimization.

Backtracking is the engine behind sudoku solvers, constraint satisfaction problems, and many AI search algorithms. Learning to prune the search space efficiently (though not required here due to small input) transfers to larger problems where smart pruning is essential.

The problem also reinforces careful handling of edge cases: division by zero, floating-point precision, and non-commutative operations (a-b ≠ b-a, a÷b ≠ b÷a).

## Examples

**Example 1:**
- Input: `cards = [4,1,8,7]`
- Output: `true`
- Explanation: One valid expression is (8-4) * (7-1) = 4 * 6 = 24

**Example 2:**
- Input: `cards = [1,2,1,2]`
- Output: `false`

## Constraints

- cards.length == 4
- 1 <= cards[i] <= 9

## Think About

1. What makes this problem challenging? What's the core difficulty?
2. Can you identify subproblems? Do they overlap?
3. What invariants must be maintained?
4. Is there a mathematical relationship to exploit?

## Approach Hints

<details>
<summary>Hint 1: Backtracking Through All Combinations</summary>

The key insight is to try all possible ways to combine the numbers:
1. Pick any 2 numbers from the list
2. Apply any of the 4 operations
3. Replace those 2 numbers with the result
4. Recursively check if remaining 3 numbers can make 24
5. Continue until only 1 number remains

With 4 numbers, you have:
- C(4,2) = 6 ways to pick first pair
- 4 operations
- Then C(3,2) = 3 ways to pick from 3 remaining
- And so on...

Total combinations are manageable: approximately 6 × 4 × 3 × 4 × 1 × 4 = 1152 cases.

</details>

<details>
<summary>Hint 2: Use Floating Point and Epsilon Comparison</summary>

Since division can produce non-integers, use floating-point arithmetic. When checking if we reached 24, use epsilon comparison to handle precision issues:

```python
def judgePoint24(cards):
    def backtrack(nums):
        if len(nums) == 1:
            return abs(nums[0] - 24) < 1e-6

        # Try all pairs
        for i in range(len(nums)):
            for j in range(len(nums)):
                if i == j:
                    continue

                # Get remaining numbers
                remaining = [nums[k] for k in range(len(nums)) if k != i and k != j]

                # Try all operations
                for op_result in [
                    nums[i] + nums[j],
                    nums[i] - nums[j],
                    nums[i] * nums[j],
                    nums[i] / nums[j] if nums[j] != 0 else float('inf')
                ]:
                    if backtrack(remaining + [op_result]):
                        return True

        return False

    return backtrack([float(x) for x in cards])
```

</details>

<details>
<summary>Hint 3: Optimize with Symmetry and Early Pruning</summary>

Optimizations to consider:
1. **Commutative operations**: For + and ×, avoid computing both (a, b) and (b, a)
2. **Division by zero**: Skip when denominator is 0
3. **Pruning impossible paths**: If intermediate result exceeds reasonable bounds, skip

However, with only 4 numbers and ~1000 combinations, brute force is acceptable.

</details>

## Complexity Analysis

| Approach | Time Complexity | Space Complexity | Notes |
|----------|----------------|------------------|-------|
| Backtracking | O(1) | O(1) | Fixed 4 numbers; constant ~1152 operations |
| Optimized Backtracking | O(1) | O(1) | Pruning reduces constants but still O(1) |
| DFS with Memoization | O(1) | O(1) | Limited benefit due to small input |

## Common Mistakes

**Mistake 1: Integer Division**
```python
# Wrong: Using integer division
result = nums[i] // nums[j]

# Correct: Use floating-point division
result = nums[i] / nums[j]
```

**Mistake 2: Exact Equality Check**
```python
# Wrong: Floating-point equality
if nums[0] == 24:
    return True

# Correct: Use epsilon for comparison
if abs(nums[0] - 24) < 1e-6:
    return True
```

**Mistake 3: Not Handling Division by Zero**
```python
# Wrong: Division without check
operations = [a+b, a-b, a*b, a/b, b/a]

# Correct: Check for zero divisor
operations = [a+b, a-b, a*b]
if b != 0:
    operations.append(a/b)
if a != 0:
    operations.append(b/a)
```

**Mistake 4: Forgetting Non-Commutative Operations**
```python
# Wrong: Only trying a-b, missing b-a
if backtrack(remaining + [nums[i] - nums[j]]):
    return True

# Correct: Try both orders for - and /
for result in [nums[i] - nums[j], nums[j] - nums[i]]:
    if backtrack(remaining + [result]):
        return True
```

## Variations

| Variation | Difficulty | Key Difference |
|-----------|-----------|----------------|
| Reach any target (not just 24) | Easy | Parameterize target value |
| Use n cards instead of 4 | Hard | Exponential complexity grows |
| Return the expression string | Medium | Track operation history |
| Use each card at most once (not all) | Medium | Allow partial card usage |
| Add more operators (exponent, mod) | Medium | More operations to try |

## Practice Checklist

- [ ] First attempt (blind)
- [ ] Analyzed time/space complexity
- [ ] Solved without hints
- [ ] Tested edge cases (all same number, impossible cases)
- [ ] Reviewed alternative approaches
- [ ] Practiced again after 1 day
- [ ] Practiced again after 1 week
- [ ] Could explain solution to others
